<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>freertos</title>
    <url>/syy.github.io/2025/09/11/hello-world/</url>
    <content><![CDATA[<h1>freertos002</h1>
<p>测试中</p>
<h2 id="1-硬件初始化">1.硬件初始化</h2>
<p>为了方便以后统一管理板级外设的初始化，我们在 main.c 文件中创建一个 BSP_Init()函数， 专门用于存放板级外设初始化函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* @ 函数名  ： BSP_Init</span></span><br><span class="line"><span class="comment">* @ 功能说明： 板级外设初始化，所有板子上的初始化均可放在这个函数里面</span></span><br><span class="line"><span class="comment">* @ 参数    ：</span></span><br><span class="line"><span class="comment">* @ 返回值  ： 无</span></span><br><span class="line"><span class="comment">  *********************************************************************/</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">BSP_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * STM32中断优先级分组为4，即4bit都用来表示抢占优先级，范围为：0~15</span></span><br><span class="line"><span class="comment">    * 优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，</span></span><br><span class="line"><span class="comment">    * 都统一用这个优先级分组，千万不要再分组，切忌。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* LED 初始化 */</span></span><br><span class="line">  LED_GPIO_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 串口初始化	*/</span></span><br><span class="line">  USART_Config();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>嵌入式</tag>
        <tag>理论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统001</title>
    <url>/syy.github.io/2025/09/08/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<!-- ![美女压图](/img/s002.jpg)

-->
<h1>信号与系统001</h1>
<p>目前还是测试的,具体内容往后再看看;</p>
<h2 id="卷积">卷积</h2>
<h3 id="卷积的性质">卷积的性质</h3>
<ul>
<li>1.分配律</li>
<li>2.交换律</li>
<li>3.两个信号卷积后的微分，等于其中一个信号的微分与另一个信号的卷积</li>
<li>4.<span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\(&#039; in math mode at position 1: \̲(̲ h(t+t_0) * x(t…'>\( h(t+t_0) * x(t-t_0) = h(t) * x(t) \)</span></li>
<li>LTI 系统稳定的充要条件是<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi mathvariant="normal">∣</mi><mi>h</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>d</mi><mi>t</mi><mo>&lt;</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\int_{-\infty}^{+\infty} |h(t)| \, dt &lt; +\infty 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span></span></p>
或<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mi mathvariant="normal">∣</mi><mi>h</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\sum_{k=-\infty}^{+\infty} |h[k]| &lt; +\infty 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.11878em;vertical-align:-1.360444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7583360000000003em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">∞</span></span></span></span></span></p>
</li>
</ul>
<h3 id="lti系统的因果充要条件">LTI系统的因果充要条件</h3>
<ul>
<li>h(t)=0,当t&lt;0时,或者h[n]=0,当n&lt;0时</li>
<li>因果的定义：输出 $( y(t) ) $在 $( t_0 ) $时刻的 <span class='katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;\(&#039; in math mode at position 1: \̲(̲ y(t_0) \)'>\( y(t_0) \)</span>，只有$ ( t \leq t_0 ) $时刻的 $( x(t) ) $决定。</li>
</ul>
<hr>
<blockquote>
<p>学习是一个持续的过程，每一小步都是进步。</p>
</blockquote>
]]></content>
      <tags>
        <tag>理论学习</tag>
        <tag>专业课</tag>
      </tags>
  </entry>
  <entry>
    <title>植物大战僵尸制作</title>
    <url>/syy.github.io/2025/09/12/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h1>植物大战僵尸</h1>
<p>目前打算先用cpp实现在电脑,再移植到stm32f407(lvgl,freertos)[还在实现中]</p>
<h2 id="cpp实现植物大战僵尸僵尸">cpp实现植物大战僵尸僵尸</h2>
<pre><code class="language-cpp">/*
    main.cpp
	1.创建新的项目
	2.添加图形库
	3.实现最开始的游戏场景
	4.实现游戏顶部的工具栏
	5.实现工具栏的卡牌
*/
#define _CRT_SECURE_NO_WARNINGS  // 必须放在最顶部，否则可能不生效
#include&lt;stdio.h&gt;
#include&lt;graphics.h&gt;//引用图形库头文件
#include &lt;Windows.h&gt;
#include &lt;conio.h&gt;
#include&quot;tools.h&quot; 

#define WIN_WIDTH 900 //游戏窗口宽度
#define WIN_HEIGHT 600 //游戏窗口高度

enum &#123;WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT&#125;;

IMAGE imgBg; //表示背景图片
IMAGE imgBar; //表示游戏中的任务栏
IMAGE imgCards[ZHI_WU_COUNT];
IMAGE* imgZhiWu[ZHI_WU_COUNT][20]; //表示植物图片

int curX, curY; //表示当前鼠标的坐标
int curZhiWu = 0; //表示当前选中的植物 0未选中,1豌豆射手,2向日葵

struct zhiwu&#123;
	int type; //0:没有植物;1:有植物;
	int frameIndex; //当前播放到第几帧
&#125;;

struct zhiwu map[3][9]; //表示游戏中的植物

struct sunshineBall &#123;
	int x, y; //阳光的坐标 
	int frameIndex; //当前播放到第几帧
	int destY; //阳光掉落的目标y坐标
	int used; //是否被使用 0:未使用 1:已使用 
&#125;; 

//10个阳光球(循环出现)
struct sunshineBall balls[10];
IMAGE imgSunshineBall[29]; //阳光图片

bool fileExist(const char* name) &#123;
	FILE* fp = fopen(name, &quot;r&quot;);
	if(fp == NULL) &#123;
		return false;
	&#125;
	else &#123;
		fclose(fp);
		return true;
	&#125;
&#125;

void gameInit()
&#123;
	//加载游戏背景
	loadimage(&amp;imgBg, _T(&quot;res/bg.jpg&quot;)); //加载背景图片
	loadimage(&amp;imgBar, _T(&quot;res/bar5.png&quot;)); //加载矩形条图片

	memset(imgZhiWu, 0, sizeof(imgZhiWu)); //将植物图片数组清零
	memset(map, 0, sizeof(map)); //将植物地图清零

	//初始化植物卡牌
	char name[64];
	for (int i =  0;i &lt; ZHI_WU_COUNT; i++)
	&#123;
		//生成植物卡牌的文件名
		wchar_t wname[64];
		// 2. 生成窄字符路径（原逻辑不变）
		sprintf_s(name, sizeof(name), &quot;res/Cards/card_%d.png&quot;, i + 1);
		// 3. 转换窄字符到宽字符（需要包含 Windows.h）
		MultiByteToWideChar(CP_ACP, 0, name, -1, wname, 64);
		// 4. 传入宽字符路径
		loadimage(&amp;imgCards[i], wname);

		for(int j = 0; j &lt; 20; j++)&#123;
			sprintf_s(name, sizeof(name), &quot;res/ZhiWu/%d/%d.png&quot;, i , j+1);
			MultiByteToWideChar(CP_ACP, 0, name, -1, wname, 64);
			//imgZhiWu[i][j] = new IMAGE;
			//判断文件是否存在
			if (fileExist(name)) &#123;
				imgZhiWu[i][j] = new IMAGE;
				loadimage(imgZhiWu[i][j], wname);
			&#125;else&#123;
				imgZhiWu[i][j] = NULL;
				break; //文件不存在，跳出循环
			&#125;
			
		&#125;
	&#125;

	memset(balls, 0, sizeof(balls)); //将阳光球数组清零


	//创建游戏窗口:
	initgraph(WIN_WIDTH, WIN_HEIGHT, 1); //创建800*600的窗口，显示控制台，禁止关闭和最小化
	
	//关闭图形窗口
	//closegraph();
&#125;

void updateWindow()
&#123;
	BeginBatchDraw(); //开始批量绘图，防止闪烁(双缓冲
	//绘制背景图片
	putimage(0, 0, &amp;imgBg); //将背景图片绘制到窗口的(0,0)位置
	putimagePNG(250, 0, &amp;imgBar); //将任务栏图片绘制到窗口底部

	for (int i = 0; i &lt; ZHI_WU_COUNT; i++)
	&#123;
		int x = 338 + i * 65; //计算每张卡牌的x坐标
		int y = 6; //卡牌的y坐标固定为6
		putimage(x, y, &amp;imgCards[i]); //将植物卡牌绘制到任务栏上
		//putimagePNG(50 + i * 80, 10, &amp;imgCards[i]); //将植物卡牌绘制到任务栏上
	&#125;

	//渲染拖动窗口
	if (curZhiWu &gt; 0) &#123;
		IMAGE* img = imgZhiWu[curZhiWu - 1][0];
		putimagePNG(curX - img-&gt;getwidth()/2, curY -img-&gt;getheight()/2, img);
		//putimagePNG(curX , curY , img);
	&#125;

	for (int i = 0; i &lt; 3; i++) &#123;
		for (int j = 0; j &lt; 9; j++) &#123;
			if (map[i][j].type &gt; 0) &#123;
				int x = 256 + j * 81;
				int y = 179 + i * 102+10;
				int zhiwutype = map[i][j].type-1;
				int index = map[i][j].frameIndex;
				//putimagePNG(curX , curY , img);
				if (imgZhiWu[zhiwutype][index] != NULL) &#123;
					putimagePNG(x, y, imgZhiWu[zhiwutype][index]);
				&#125;
			&#125;
		&#125;
	&#125;

	//刷新图形窗口
	//FlushBatchDraw(); //刷新图形窗口，显示所有绘制的内容
	EndBatchDraw(); //结束批量绘图，显示所有绘制的内容

&#125;

//用户的点击事件
void userClick()&#123;
	ExMessage msg; //专门用来存储图形窗口中发生的消息
	static int status = 0; //用来表示当前的状态，0表示没有点击任何卡牌，1表示点击了某张卡牌

	//peekmessage(); //处理鼠标消息
	if(peekmessage(&amp;msg))&#123;
		if (msg.message == WM_LBUTTONDOWN) &#123; //左键按下
			if(msg.x&gt; 338 &amp;&amp; msg.x &lt; 338 + 65 * ZHI_WU_COUNT &amp;&amp; msg.y &gt; 6 &amp;&amp; msg.y &lt; 96)&#123;
				int index = (msg.x - 338) / 65; //计算用户点击的是第几张卡牌
				status = 1; //表示用户点击了某张卡牌
				curZhiWu = index + 1; //记录当前选中的植物
			&#125;
		&#125;
		else if (msg.message == WM_MOUSEMOVE &amp;&amp; status == 1) &#123; //鼠标移动
			curX = msg.x;
			curY = msg.y;

		&#125;
		else if (msg.message == WM_LBUTTONUP) &#123; //鼠标左键抬起
			if (msg.x &gt; 256 &amp;&amp; msg.y &gt; 179 &amp;&amp; msg.y &lt; 489) &#123;
				int row = (msg.y - 179) / 102; //计算用户松开鼠标时，植物应该种植在哪一行
				int col = (msg.x - 256) / 81; //计算用户松开鼠标时，植物应该种植在哪一列

				if (map[row][col].type == 0) &#123;
					map[row][col].type = curZhiWu;
					map[row][col].frameIndex;

				&#125;
				//status = 0; // 重置“拖动状态”
				//curZhiWu = 0; // 重置“选中植物”（后续可改为“判断种植后再重置”
			&#125;
			
		&#125;
	&#125;
	
&#125;

//改变游戏的状态
void updateGame()&#123;
	// 1. 静态变量记录上一次更新动画的时间（只初始化一次）
	static DWORD lastAnimTime = 0;
	// 2. 当前时间（毫秒）
	DWORD now = GetTickCount();
	// 3. 动画更新间隔：100毫秒（可调整，值越大动画越慢）
	const int ANIM_INTERVAL = 100;


	// 只有当时间间隔超过100毫秒，才更新动画帧
	if (now - lastAnimTime &gt;= ANIM_INTERVAL) &#123;
		// 更新植物的动画（原逻辑不变，只是包在时间判断里）
		for (int i = 0; i &lt; 3; i++) &#123;
			for (int j = 0; j &lt; 9; j++) &#123;
				if (map[i][j].type &gt; 0) &#123;
					int zhiwutype = map[i][j].type - 1;
					// 修复：原代码判断的是“更新前的帧”，这里改成“更新后的帧”
					map[i][j].frameIndex++;
					// 检查下一帧是否存在，不存在则重置为0
					if (imgZhiWu[zhiwutype][map[i][j].frameIndex] == NULL) &#123;
						map[i][j].frameIndex = 0;
					&#125;
				&#125;
			&#125;
		&#125;
		// 4. 更新“上一次动画时间”，为下次判断做准备
		lastAnimTime = now;
	&#125;
&#125;
void startUI()&#123;
	IMAGE imgBg,imgMenu1, imgMenu2;
	loadimage(&amp;imgBg, _T(&quot;res/menu.png&quot;));
	loadimage(&amp;imgMenu1, _T(&quot;res/menu1.png&quot;));
	loadimage(&amp;imgMenu2, _T(&quot;res/menu2.png&quot;));

	int flag = 0;

	while (1)&#123;
		BeginBatchDraw(); //开始批量绘图，防止闪烁(双缓冲
		putimage(0, 0, &amp;imgBg); //将背景图片绘制到窗口的(0,0)位置
		putimagePNG(474, 75, flag ? &amp;imgMenu2 : &amp;imgMenu1);
		EndBatchDraw(); //结束批量绘图，显示所有绘制的内容 

		ExMessage msg; //专门用来存储图形窗口中发生的消息
		if(peekmessage(&amp;msg))&#123;
			if (msg.message == WM_MOUSEMOVE) &#123; //鼠标移动
				if (msg.x &gt; 474 &amp;&amp; msg.x &lt; 474 + 300 &amp;&amp; msg.y &gt; 75 &amp;&amp; msg.y &lt; 75 + 100) &#123;
					flag = 1;
				&#125;
				else &#123;
					flag = 0;
				&#125;
			&#125;
			else if (msg.message == WM_LBUTTONDOWN) &#123; //左键按下
				if (msg.x &gt; 474 &amp;&amp; msg.x &lt; 474 + 300 &amp;&amp; msg.y &gt; 75 &amp;&amp; msg.y &lt; 75 + 100) &#123;
					break;
				&#125;
			&#125;
		&#125;

	&#125;
&#125;

int main()&#123;
	gameInit();

	startUI();

	int timer = 0;
	int flag = true;

	while (1) &#123;
		userClick();
		timer += getDelay();

		updateGame();
		updateWindow();

		// 新增：用定时器控制帧率（16毫秒≈60FPS，不阻塞输入）
		static DWORD lastFrameTime = 0;
		DWORD now = GetTickCount();
		if (now - lastFrameTime &lt; 16) &#123;  // 确保每帧至少间隔16毫秒
			Sleep(now - lastFrameTime);  // 只在“帧太快”时轻微延时，不阻塞输入
		&#125;
		lastFrameTime = now;

		
	&#125;
	

	system(&quot;pause&quot;); //等待用户按任意键
	return 0;
&#125;

</code></pre>
]]></content>
      <tags>
        <tag>嵌入式</tag>
        <tag>lvgl</tag>
        <tag>freertos</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
</search>
